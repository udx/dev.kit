{
  "title": "CDE definition",
  "summary": "Context Driven Engineering (CDE) is a repository standard that ensures components remain usable and consistent across all development context layers: human, programmatic, and AI. This document is the CDE definition for dev.kit.",
  "_order": [
    "transformation",
    "developmentContextLayers",
    "dynamicSchema",
    "repositoryStructure",
    "navigation",
    "artifacts",
    "validationTests",
    "contextLayers",
    "vocabulary",
    "designPrinciple",
    "extensions"
  ],
  "transformation": {
    "_heading": "Transformation",
    "items": [
      "Prompt: see `Prompt(CDE schema builder)` in this file.",
      "Destination: `src/schema/index.json`."
    ]
  },
  "developmentContextLayers": {
    "_heading": "Development context layers",
    "items": [
      "**Software-specific standard (build)** Defines how source artifacts are discovered, built, tested, scanned, signed, and packaged.",
      "**12-factor GitHub repo standard (deployment)** Defines how repositories behave as deployable units via conventions, declarative configuration, and environment separation.",
      "**Context Driven Engineering (active context layer)** Defines how execution context influences behavior across all layers. This layer is always active and never bypassed."
    ]
  },
  "dynamicSchema": {
    "_heading": "Dynamic schema",
    "_order": [
      "indexInheritance",
      "mergeOrder",
      "dynamicVariables",
      "naming"
    ],
    "indexInheritance": {
      "_heading": "Index inheritance",
      "items": [
        "`index.md` defines schema rules for the current directory scope.",
        "Only directories containing an `index.md` participate as context layers.",
        "A child directory `index.md` extends parent rules.",
        "Overrides are allowed only when the parent explicitly permits overrides for a given key."
      ]
    },
    "mergeOrder": {
      "_heading": "Merge order",
      "items": [
        "Apply parent rules (base).",
        "Apply child rules (extensions).",
        "If overrides are permitted: child values replace parent values for the same keys.",
        "If overrides are not permitted: child may only add new keys."
      ]
    },
    "dynamicVariables": {
      "_heading": "Dynamic variables",
      "items": [
        "`$child` resolves to all child dirs in the current directory. Alias for `$child.dirs`.",
        "`$child.files` resolves to all child files in the current directory.",
        "`$child[context]` resolves to all child files in `context/`. If absent or empty, returns `[]`.",
        "Non-wrapped variables are executable.",
        "Non-executable text: wrap in code fences to keep it literal."
      ]
    },
    "naming": {
      "_heading": "Naming",
      "items": [
        "Use lowercase kebab-case for directory and file names.",
        "Use `index.md` as the entry point for each directory."
      ]
    }
  },
  "repositoryStructure": {
    "_heading": "Repository structure",
    "items": [
      "`src/` Source manifests for humans, programs, and AI, including the CDE definition.",
      "`public/` Public artifacts of built documentation.",
      "**Note:** the artifacts destination can be configured per context layer."
    ]
  },
  "navigation": {
    "_heading": "Navigation",
    "items": [
      "Each directory should contain an `index.md` that documents its direct children only.",
      "Do not list deep files; rely on child indexes for discovery.",
      "If `index.md` is missing, defaults apply but may be inaccurate due to absent metadata."
    ]
  },
  "artifacts": {
    "_heading": "Artifacts",
    "items": [
      {
        "text": "Artifacts are derived with:",
        "items": [
          "`dev.kit build [--context=configs/modules/ai/codex]`"
        ]
      },
      "Artifacts may be `md`, `json`, `yml`, or module-specific formats."
    ]
  },
  "validationTests": {
    "_heading": "Validation & Tests",
    "items": [
      "Human readability is the primary goal.",
      "Machine parsing should be simple, deterministic, and tolerant of minor variations.",
      "AI context depends on prompt generation and may vary across clients.",
      "Explicit sections/headings are optional but recommended when they improve clarity."
    ]
  },
  "contextLayers": {
    "_heading": "Context layers",
    "_order": [
      "humanBuild",
      "programmaticDeploy",
      "aiContext"
    ],
    "humanBuild": {
      "_heading": "human/build",
      "summary": "Human-initiated, interactive build execution.",
      "items": [
        {
          "id": "custom",
          "description": "Parameterized, operator-defined execution path."
        },
        {
          "id": "real-time",
          "description": "Observable execution with live feedback and step visibility."
        },
        {
          "id": "multi-step",
          "description": "Guided execution flow with state, checkpoints, and progressive disclosure (wizard-style, context-aware)."
        }
      ]
    },
    "programmaticDeploy": {
      "_heading": "programmatic/deploy",
      "summary": "Machine-initiated, deterministic deployment execution.",
      "items": [
        {
          "id": "inputs",
          "description": "Explicit input contract (flags, payloads, schema-validated parameters)."
        },
        {
          "id": "default",
          "description": "Opinionated execution using standard inputs and conventions."
        },
        {
          "id": "single/scroll",
          "description": "Single, linear execution record optimized for inspection and automation."
        }
      ]
    },
    "aiContext": {
      "_heading": "ai/context",
      "summary": "Context-aware, adaptive execution and orchestration.",
      "items": [
        {
          "id": "interpret",
          "description": "Derives intent from partial, ambiguous, or conversational input."
        },
        {
          "id": "compose",
          "description": "Assembles workflows dynamically from standards and active context."
        },
        {
          "id": "mediate",
          "description": "Bridges human intent and programmatic execution safely and predictably."
        },
        {
          "id": "optimize",
          "description": "Adjusts steps, ordering, or defaults based on historical and situational context."
        }
      ]
    }
  },
  "vocabulary": {
    "_heading": "Vocabulary",
    "summary": "Vocabulary is layer-agnostic and maps consistently across experiences and layers.",
    "_order": [
      "coreTerms",
      "experience",
      "aiEssentialsAndHumanAnalogy"
    ],
    "coreTerms": {
      "_heading": "Core terms",
      "items": [
        {
          "id": "context-layer",
          "description": "A directory that contains an `index.md`. Only such directories participate in CDE context resolution."
        },
        {
          "id": "context-asset",
          "description": "A markdown document located within a context layer (typically `index.md` or any document under that layer's `context/` subtree)."
        },
        {
          "id": "context-schema",
          "description": "A JSON configuration that defines machine-validated structure for a context layer (e.g., `index.json`, `schema.json`, or an embedded JSON schema block)."
        }
      ]
    },
    "experience": {
      "_heading": "Experience",
      "items": [
        {
          "id": "interactive",
          "description": "Human-friendly guided or conversational flow (CLI wizard, UI, AI-guided)."
        },
        {
          "id": "programmatic",
          "description": "Machine-friendly, explicit and deterministic (CLI flags, API payloads, CI pipelines)."
        },
        {
          "id": "integrated",
          "description": "Declarative, configuration-driven (config files, repo manifests, policy definitions)."
        }
      ]
    },
    "aiEssentialsAndHumanAnalogy": {
      "_heading": "AI Essentials and Human Analogy",
      "_order": [
        "aiEssentials",
        "humanCapabilityBuild",
        "programmaticCapabilityDeploy"
      ],
      "aiEssentials": [
        {
          "aiEssential": "**interpret**",
          "humanAnalogyWhatItLooksLike": "Clarify intent, restate requirements, ask the right steps",
          "typicalOutputArtifact": "Intent summary"
        },
        {
          "aiEssential": "**compose**",
          "humanAnalogyWhatItLooksLike": "Draft a runbook, choose an approach, sequence steps",
          "typicalOutputArtifact": "Plan / workflow spec"
        },
        {
          "aiEssential": "**mediate**",
          "humanAnalogyWhatItLooksLike": "Gatekeeping, approvals, policy checks, safety reviews",
          "typicalOutputArtifact": "Decision record"
        },
        {
          "aiEssential": "**optimize**",
          "humanAnalogyWhatItLooksLike": "Refactor, simplify, reuse patterns, avoid repetition",
          "typicalOutputArtifact": "Improved plan / defaults"
        }
      ],
      "humanCapabilityBuild": [
        {
          "humanCapabilityBuild": "**custom**",
          "aiAnalogWhatAiDoes": "Parameter selection and constraint satisfaction",
          "typicalOutputArtifact": "Parameter set"
        },
        {
          "humanCapabilityBuild": "**real-time**",
          "aiAnalogWhatAiDoes": "Live summarization + anomaly surfacing",
          "typicalOutputArtifact": "Status narrative"
        },
        {
          "humanCapabilityBuild": "**multi-step**",
          "aiAnalogWhatAiDoes": "Stateful orchestration + checkpointing",
          "typicalOutputArtifact": "Step trace"
        }
      ],
      "programmaticCapabilityDeploy": [
        {
          "programmaticCapabilityDeploy": "**inputs**",
          "aiAnalogWhatAiDoes": "Schema-driven extraction/validation",
          "typicalOutputArtifact": "Validated payload"
        },
        {
          "programmaticCapabilityDeploy": "**default**",
          "aiAnalogWhatAiDoes": "Default selection using context + policy",
          "typicalOutputArtifact": "Resolved configuration"
        },
        {
          "programmaticCapabilityDeploy": "**single/scroll**",
          "aiAnalogWhatAiDoes": "Post-run synthesis into one consumable trace",
          "typicalOutputArtifact": "Run report"
        }
      ]
    }
  },
  "designPrinciple": {
    "_heading": "Design principle",
    "summary": "The same action must be expressible as:",
    "items": [
      "a conversation (AI),",
      "a guided flow (human),",
      "a contract (programmatic),"
    ],
    "notes": [
      "without changing its meaning.",
      "AI does not introduce a new execution model; it acts as a context compiler that selects the appropriate layer and experience."
    ]
  },
  "extensions": {
    "notes": [
      {
        "_heading": "Prompt(CDE schema builder)",
        "value": "You are a deterministic converter that transforms a single CDE Markdown document into a single JSON artifact.\n\nTenet: the Markdown is the configuration and source of truth. This prompt is only the script. Do not embed or assume any CDE-specific content beyond the generic conversion rules below.\n\nOutput requirements\n- Output JSON only. No markdown fences, no commentary.\n- Deterministic: same input -> same JSON output.\n- Do not invent content. If something is absent in Markdown, omit it in JSON (unless required by the schema you infer from the Markdown itself).\n- Preserve literals exactly (code blocks, inline code, tokens like $vars). Never execute or expand variables.\n- Prefer stable identifiers and round-trip safety.\n\nParsing and normalization rules\n\n1) Document framing\n- H1 becomes: title\n- The first paragraph after H1 (if any) becomes: summary\n\n2) Headings -> structure\n- H2 headings create top-level JSON sections.\n- H3+ headings create nested objects inside their nearest parent section.\n- Heading keys must be normalized to lowerCamelCase.\n- Preserve original heading text in an optional field: _heading (string) when useful for round-trip fidelity.\n\n3) Lists\n- Numbered lists become arrays preserving order.\n- Bullet lists become arrays.\n- Definition-style bullets are detected and normalized:\n  - Pattern A: \"**term**: description\" -> object { id, description }\n  - Pattern B: \"term: description\" (when term is short and description is longer) -> object { id, description }\n- Normalize ids:\n  - If the id contains \"/\" keep it as-is.\n  - Otherwise lower-case; convert spaces to \"-\" (kebab-case); strip surrounding punctuation.\n\n4) Tables\n- Markdown tables become arrays of row objects.\n- Header cells become object keys (normalized to lowerCamelCase).\n- Keep dashes and placeholders as literal strings (do not coerce to null).\n\n5) Code blocks and literals\n- Any fenced code block becomes an object:\n  { \"type\": \"code\", \"lang\": \"<lang or empty>\", \"value\": \"<exact contents>\" }\n- Attach code objects to the closest relevant section based on proximity:\n  - If inside a heading section, store under that section.\n  - If unclear, store in a top-level array: literals[].\n\n6) Inline code\n- Preserve inline code verbatim in the surrounding string content.\n- Do not interpret inline code as structure unless it matches a definition/list rule.\n\n7) Round-trip fidelity\n- Preserve order where meaningful:\n  - For each object created from headings, optionally include _order: [<child keys in appearance order>].\n  - For arrays derived from lists, preserve list order.\n- If you encounter content that does not fit any rule, store it under:\n  extensions: { notes: [ ... ] }\n  Do not drop information.\n\n8) Root metadata\n- If the Markdown provides explicit spec/version metadata, include it.\n- If not provided, omit spec/version fields (do not guess).\n\n9) Final output\n- Emit one JSON object as the sole output.\n- Ensure the JSON is valid, UTF-8, and uses consistent key naming (lowerCamelCase for keys; ids as described above)."
      }
    ]
  }
}
