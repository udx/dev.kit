{
  "id": "git",
  "version": "0.1",
  "title": "Git Module",
  "components": {
    "docs": [
      {
        "id": "git.guide",
        "path": "docs/src/configs/guides/git-guide.md",
        "tags": ["git", "workflow", "commands"]
      },
      {
        "id": "dev.tenets",
        "path": "docs/src/configs/principles/development-tenets.md",
        "tags": ["workflow", "quality", "tenets"]
      }
    ],
    "prompts": [
      {
        "id": "git.reset.unpushed",
        "text": "remove latest unpushed commits",
        "workflow_id": "git.reset.unpushed"
      },
      {
        "id": "git.cleanup.history",
        "text": "cleanup git history before PR",
        "workflow_id": "git.cleanup.history"
      },
      {
        "id": "git.cleanup.history.squash",
        "text": "squash commits before PR",
        "workflow_id": "git.cleanup.history"
      }
    ],
    "workflows": [
      {
        "id": "git.reset.unpushed",
        "title": "Remove latest unpushed commits",
        "edge_cases": [
          "If commits are already pushed, use git revert or coordinate a rewrite.",
          "If you are on a protected branch, history rewrite may be blocked."
        ],
        "steps": [
          {
            "id": "git.reset.soft",
            "command": "git reset --soft HEAD~1",
            "note": "Keep changes staged.",
            "runnable": false
          },
          {
            "id": "git.reset.mixed",
            "command": "git reset --mixed HEAD~1",
            "note": "Keep changes in working tree.",
            "runnable": false
          },
          {
            "id": "git.reset.hard",
            "command": "git reset --hard HEAD~1",
            "note": "Discard changes (destructive).",
            "runnable": false
          }
        ],
        "response": {
          "instructions": [
            "Verify commits are not pushed before using reset.",
            "Choose soft/mixed/hard based on desired preservation.",
            "Prefer soft or mixed unless you are discarding changes."
          ],
          "normalized": "To remove unpushed commits, use git reset with soft/mixed/hard based on whether you want to keep staged or working changes. Always confirm the commits are local."
        }
      },
      {
        "id": "git.cleanup.history",
        "title": "Cleanup history before PR",
        "edge_cases": [
          "If the branch is shared, confirm with collaborators before rewriting.",
          "If there are uncommitted changes, stash or commit before rebase."
        ],
        "steps": [
          {
            "id": "git.backup.branch",
            "command": "git branch backup/cleanup-$(date +%Y%m%d)",
            "note": "Create a safety branch.",
            "runnable": false
          },
          {
            "id": "git.fetch",
            "command": "git fetch origin",
            "note": "Sync remotes before rebase.",
            "runnable": false
          },
          {
            "id": "git.rebase.interactive",
            "command": "git rebase -i origin/main",
            "note": "Reword, squash, or drop commits.",
            "runnable": false,
            "interactive": true
          },
          {
            "id": "git.push.force",
            "command": "git push --force-with-lease",
            "note": "Safely update rewritten history.",
            "runnable": false,
            "protected": true,
            "preview_command": "git push --force-with-lease --dry-run"
          }
        ],
        "response": {
          "instructions": [
            "Create a backup branch before rewriting history.",
            "Use interactive rebase to squash or reword commits.",
            "Preview the push with --dry-run, then use --force-with-lease."
          ],
          "normalized": "Cleanup PR history with an interactive rebase onto main, using a backup branch first, and push the rewritten branch using --force-with-lease."
        }
      }
    ]
  }
}
