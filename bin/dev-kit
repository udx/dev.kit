#!/bin/bash
set -euo pipefail

usage() {
  cat <<'USAGE'
Usage: dev.kit <command>

Commands:
USAGE
  local cmd
  while IFS= read -r cmd; do
    [ -n "$cmd" ] && printf "  %s\n" "$cmd"
  done < <(list_commands)
}

resolve_self() {
  if command -v python3 >/dev/null 2>&1; then
    python3 - <<'PY' "$0"
import os,sys
print(os.path.realpath(sys.argv[1]))
PY
    return
  fi
  echo "$0"
}

SCRIPT_PATH="$(resolve_self)"
REPO_DIR="$(cd "$(dirname "$SCRIPT_PATH")/.." && pwd)"

UI_LIB="$REPO_DIR/lib/ui.sh"
if [ -f "$UI_LIB" ]; then
  # shellcheck disable=SC1090
  . "$UI_LIB"
fi

print_section() {
  local title="$1"
  if command -v ui_section >/dev/null 2>&1; then
    ui_section "$title"
  else
    echo ""
    echo "== $title =="
  fi
}

print_check() {
  local label="$1"
  local status="$2"
  local detail="${3:-}"
  if command -v ui_ok >/dev/null 2>&1 && [ "$status" = "[ok]" ]; then
    ui_ok "$label" "$detail"
    return
  fi
  if command -v ui_warn >/dev/null 2>&1 && [ "$status" = "[warn]" ]; then
    ui_warn "$label" "$detail"
    return
  fi
  printf "%-20s %s" "$label" "$status"
  if [ -n "$detail" ]; then
    printf "  %s" "$detail"
  fi
  printf "\n"
}

ensure_dev_kit_home() {
  mkdir -p "$DEV_KIT_HOME"
  if [ ! -w "$DEV_KIT_HOME" ]; then
    echo "dev.kit: config path not writable: $DEV_KIT_HOME" >&2
    echo "dev.kit: fix permissions or choose a different DEV_KIT_HOME" >&2
    exit 1
  fi
  if [ ! -f "$CONFIG_FILE" ] && [ -f "$REPO_DIR/config/default.env" ]; then
    cp "$REPO_DIR/config/default.env" "$CONFIG_FILE"
  fi
}

config_value() {
  local file="$1"
  local key="$2"
  local default="${3:-}"
  local val=""
  if [ -f "$file" ]; then
    val="$(awk -F= -v k="$key" '
      $1 ~ "^[[:space:]]*"k"[[:space:]]*$" {
        sub(/^[[:space:]]*/,"",$2);
        sub(/[[:space:]]*$/,"",$2);
        print $2;
        exit
      }
    ' "$file")"
  fi
  if [ -n "$val" ]; then
    echo "$val"
  else
    echo "$default"
  fi
}

get_repo_root() {
  if command -v git >/dev/null 2>&1; then
    git rev-parse --show-toplevel 2>/dev/null || true
  fi
}

local_config_path() {
  local root
  root="$(get_repo_root)"
  if [ -n "$root" ]; then
    echo "$root/.udx/dev.kit/config.env"
  fi
}

config_value_scoped() {
  local key="$1"
  local default="${2:-}"
  local local_path=""
  local val=""

  local_path="$(local_config_path || true)"
  if [ -n "$local_path" ] && [ -f "$local_path" ]; then
    val="$(config_value "$local_path" "$key" "")"
  fi
  if [ -n "$val" ]; then
    echo "$val"
    return
  fi
  config_value "$CONFIG_FILE" "$key" "$default"
}

capture_mode() {
  local mode=""
  mode="$(config_value_scoped capture.mode "")"
  if [ -n "$mode" ]; then
    echo "$mode"
    return
  fi
  local enabled=""
  enabled="$(config_value_scoped capture.enabled "true")"
  if [ "$enabled" = "true" ]; then
    echo "global"
  else
    echo "off"
  fi
}

capture_repo_id() {
  local root=""
  root="$(get_repo_root || true)"
  if [ -z "$root" ]; then
    root="$PWD"
  fi
  if command -v shasum >/dev/null 2>&1; then
    printf "%s" "$root" | shasum -a 256 | awk '{print $1}'
  else
    printf "%s" "$root" | cksum | awk '{print $1}'
  fi
}

capture_dir() {
  local mode base repo_id
  mode="$(capture_mode)"
  case "$mode" in
    off) return 1 ;;
    repo)
      base="$(get_repo_root || true)"
      if [ -z "$base" ]; then
        base="$PWD"
      fi
      echo "$base/.udx/dev.kit/capture"
      ;;
    global|*)
      base="$(config_value_scoped capture.dir "")"
      if [ -z "$base" ]; then
        base="$DEV_KIT_HOME/capture"
      elif [[ "$base" == "~/"* ]]; then
        base="$HOME/${base:2}"
      elif [[ "$base" != /* ]]; then
        base="$DEV_KIT_HOME/$base"
      fi
      repo_id="$(capture_repo_id)"
      echo "$base/$repo_id"
      ;;
  esac
}

capture_enabled() {
  local mode=""
  mode="$(capture_mode)"
  [ "$mode" != "off" ]
}

capture_prepare() {
  local dir input_path output_path
  dir="$(capture_dir)" || return 1
  input_path="$dir/last-input.log"
  output_path="$dir/last-output.log"
  mkdir -p "$dir"
  : > "$input_path"
  : > "$output_path"
  printf "%s | %s | %s\n" "$(date -Iseconds)" "$PWD" "$1" >> "$input_path"
  printf "%s\n" "$output_path"
}

DEV_KIT_OWNER="${DEV_KIT_OWNER:-udx}"
DEV_KIT_REPO="${DEV_KIT_REPO:-dev.kit}"
DEV_KIT_HOME="${DEV_KIT_HOME:-$HOME/.${DEV_KIT_OWNER}/${DEV_KIT_REPO}}"
CONFIG_FILE="$DEV_KIT_HOME/config.env"

expand_path() {
  local val="$1"
  if [[ "$val" == "~/"* ]]; then
    echo "$HOME/${val:2}"
    return
  fi
  if [[ "$val" == /* ]]; then
    echo "$val"
    return
  fi
  echo "$REPO_DIR/$val"
}

list_commands() {
  local file=""
  for file in "$REPO_DIR"/lib/commands/*.sh; do
    [ -e "$file" ] || continue
    basename "${file%.sh}"
  done | LC_ALL=C sort
}

for cmd_file in "$REPO_DIR"/lib/commands/*.sh; do
  [ -e "$cmd_file" ] || continue
  # shellcheck disable=SC1090
  . "$cmd_file"
done

orig_args=("$@")
cmd="${1:-help}"
case "$cmd" in
  help|-h|--help)
    usage
    exit 0
    ;;
esac

fn="dev_kit_cmd_${cmd//-/_}"
if ! command -v "$fn" >/dev/null 2>&1; then
  echo "Unknown command: $cmd" >&2
  echo ""
  usage
  exit 1
fi

ensure_dev_kit_home
if [ "$cmd" = "capture" ]; then
  "$fn" "$@"
  exit $?
fi
if capture_enabled; then
  full_cmd="dev.kit ${orig_args[*]}"
  output_path="$(capture_prepare "$full_cmd")"
  "$fn" "$@" 2>&1 | tee "$output_path"
  exit $?
fi

"$fn" "$@"
