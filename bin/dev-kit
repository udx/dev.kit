#!/bin/bash
set -euo pipefail

usage() {
  cat <<'USAGE'
Usage: dev.kit <command>

Commands:
  help        Show this help
  version     Print version
  paths       Show key local paths
  codex       Codex integration helpers (config/rules/skills)
  install     Install dev.kit to ~/.local/bin
  update      Update dev.kit from git and re-install
  uninstall   Remove dev.kit from ~/.local/bin
  enable      Append source line to a shell profile (bash/zsh)
  init        Session bootstrap (quiet after first run)
  test        Run module workflow tests (mock by default)
  session     Start/status/summary/save work sessions
  doctor      Health checks and diagnostics
  clock       Simple wall-clock helper for iteration timing
  capture     Capture shell commands for session review
  config      View or reset dev.kit config

Notes:
  This CLI is intentionally minimal. New commands will be added as we go.
USAGE
}

resolve_self() {
  if command -v python3 >/dev/null 2>&1; then
    python3 - <<'PY' "$0"
import os,sys
print(os.path.realpath(sys.argv[1]))
PY
    return
  fi
  echo "$0"
}

SCRIPT_PATH="$(resolve_self)"
REPO_DIR="$(cd "$(dirname "$SCRIPT_PATH")/.." && pwd)"
KIT_CONFIG="$REPO_DIR/config/kit.env"

print_enable_line() {
  echo "source \"$ENV_FILE\""
}

UI_LIB="${REPO_DIR}/lib/ui.sh"
if [ -f "$UI_LIB" ]; then
  # shellcheck disable=SC1090
  . "$UI_LIB"
fi

MODULE_LIB="${REPO_DIR}/lib/module.sh"
if [ -f "$MODULE_LIB" ]; then
  # shellcheck disable=SC1090
  . "$MODULE_LIB"
fi

print_section() {
  local title="$1"
  if command -v ui_section >/dev/null 2>&1; then
    ui_section "$title"
  else
    echo ""
    echo "== $title =="
  fi
}

print_check() {
  local label="$1"
  local status="$2"
  local detail="${3:-}"
  if command -v ui_ok >/dev/null 2>&1 && [ "$status" = "[ok]" ]; then
    ui_ok "$label" "$detail"
    return
  fi
  if command -v ui_warn >/dev/null 2>&1 && [ "$status" = "[warn]" ]; then
    ui_warn "$label" "$detail"
    return
  fi
  printf "%-20s %s" "$label" "$status"
  if [ -n "$detail" ]; then
    printf "  %s" "$detail"
  fi
  printf "\n"
}

ensure_dev_kit_home() {
  mkdir -p "$DEV_KIT_HOME"
  if [ ! -w "$DEV_KIT_HOME" ]; then
    echo "dev.kit: config path not writable: $DEV_KIT_HOME" >&2
    echo "dev.kit: fix permissions or choose a different DEV_KIT_HOME" >&2
    exit 1
  fi
  if [ ! -f "$CONFIG_FILE" ] && [ -f "$REPO_DIR/config/default.env" ]; then
    cp "$REPO_DIR/config/default.env" "$CONFIG_FILE"
  fi
}

config_bool() {
  local key="$1"
  local default="${2:-false}"
  local val=""
  if [ -f "$CONFIG_FILE" ]; then
    val="$(awk -F= -v k="$key" '
      $1 ~ "^[[:space:]]*"k"[[:space:]]*$" {
        gsub(/[[:space:]]/,"",$2);
        print tolower($2);
        exit
      }
    ' "$CONFIG_FILE")"
  fi
  case "$val" in
    true|false) echo "$val" ;;
    *) echo "$default" ;;
  esac
}

config_value() {
  local file="$1"
  local key="$2"
  local default="${3:-}"
  local val=""
  if [ -f "$file" ]; then
    val="$(awk -F= -v k="$key" '
      $1 ~ "^[[:space:]]*"k"[[:space:]]*$" {
        sub(/^[[:space:]]*/,"",$2);
        sub(/[[:space:]]*$/,"",$2);
        print $2;
        exit
      }
    ' "$file")"
  fi
  if [ -n "$val" ]; then
    echo "$val"
  else
    echo "$default"
  fi
}

kit_value() {
  local key="$1"
  local default="${2:-}"
  config_value "$KIT_CONFIG" "$key" "$default"
}

DEV_KIT_OWNER="${DEV_KIT_OWNER:-$(kit_value OWNER "udx")}"
DEV_KIT_REPO="${DEV_KIT_REPO:-$(kit_value REPO "dev.kit")}"
DEV_KIT_HOME="${DEV_KIT_HOME:-$HOME/.${DEV_KIT_OWNER}/${DEV_KIT_REPO}}"
ENGINE_DIR="$DEV_KIT_HOME"
ENV_FILE="$DEV_KIT_HOME/env.sh"
CONFIG_FILE="$DEV_KIT_HOME/config.env"

expand_path() {
  local val="$1"
  if [[ "$val" == "~/"* ]]; then
    echo "$HOME/${val:2}"
    return
  fi
  if [[ "$val" == /* ]]; then
    echo "$val"
    return
  fi
  echo "$REPO_DIR/$val"
}

CODEX_MODULE="$REPO_DIR/lib/modules/codex.sh"
if [ -f "$CODEX_MODULE" ]; then
  # shellcheck disable=SC1090
  . "$CODEX_MODULE"
fi

append_line() {
  local profile="$1"
  local line
  line="$(print_enable_line)"
  if [ -f "$profile" ] && grep -Fqx "$line" "$profile"; then
    echo "Already enabled in: $profile"
    return 0
  fi
  if [ -t 0 ]; then
    printf "Append to %s? [y/N] " "$profile"
    read -r answer || true
    case "$answer" in
      y|Y|yes|YES)
        printf "\n%s\n" "$line" >> "$profile"
        echo "Enabled in: $profile"
        ;;
      *)
        echo "Not modified. Add this line manually if desired:"
        print_enable_line
        ;;
    esac
  else
    echo "Non-interactive. Add this line to your profile:"
    print_enable_line
  fi
}

cmd="${1:-help}"
case "$cmd" in
  help|-h|--help)
    usage
    ;;
  version)
    echo "dev.kit 0.1.0"
    ;;
  paths)
    owner="${DEV_KIT_OWNER:-$(kit_value OWNER "udx")}"
    repo_name="${DEV_KIT_REPO:-$(kit_value REPO "dev.kit")}"
    echo "repo: $REPO_DIR"
    echo "owner/repo: ${owner}/${repo_name}"
    echo "engineering: $HOME/.udx"
    echo "cde: $HOME/git/$owner/cde"
    echo "config: $CONFIG_FILE"
    ;;
  codex)
    if command -v codex_main >/dev/null 2>&1; then
      codex_main "$@"
    else
      echo "Codex module not available." >&2
      exit 1
    fi
    ;;
  install)
    shift || true
    "$REPO_DIR/bin/scripts/install.sh" "$@"
    ;;
  update)
    "$REPO_DIR/bin/scripts/update.sh"
    ;;
  uninstall)
    "$REPO_DIR/bin/scripts/uninstall.sh" "${2:-}"
    ;;
  enable)
    profile="$HOME/.bash_profile"
    force="false"
    shift || true
    while [ $# -gt 0 ]; do
      case "$1" in
        --shell=bash) profile="$HOME/.bash_profile" ;;
        --shell=zsh) profile="$HOME/.zshrc" ;;
        --file=*) profile="${1#--file=}" ;;
        --force) force="true" ;;
      esac
      shift
    done
    if [ "$force" = "true" ]; then
      line="$(print_enable_line)"
      if [ -f "$profile" ] && grep -Fqx "$line" "$profile"; then
        echo "Already enabled in: $profile"
      else
        printf "\n%s\n" "$line" >> "$profile"
        echo "Enabled in: $profile"
      fi
    else
      append_line "$profile"
    fi
    ;;
  init)
    ensure_dev_kit_home
    quiet="$(config_bool quiet false)"
    codex_suggest="$(config_bool codex_suggest true)"
    if [ ! -f "$ENGINE_DIR/.init_done" ]; then
      if [ "$quiet" != "true" ]; then
        echo "dev.kit: initialized (run 'dev.kit help' for commands)"
      fi
      touch "$ENGINE_DIR/.init_done"
    fi
    if [ "$codex_suggest" = "true" ] && [ "$quiet" != "true" ]; then
      if command -v codex >/dev/null 2>&1; then
        echo "dev.kit: Codex detected. Consider enabling Codex support and rules integration."
      fi
    fi
    ;;
  session)
    sub="${2:-}"
    session_file="$DEV_KIT_HOME/session.json"
    template_path="$REPO_DIR/docs/src/configs/experience/templates/session-summary.md"

    ensure_engine_dir() {
      if [ ! -d "$ENGINE_DIR" ]; then
        mkdir -p "$ENGINE_DIR"
      fi
    }

    get_repo_root() {
      if command -v git >/dev/null 2>&1; then
        git rev-parse --show-toplevel 2>/dev/null || true
      fi
    }

    get_branch() {
      if command -v git >/dev/null 2>&1; then
        git rev-parse --abbrev-ref HEAD 2>/dev/null || true
      fi
    }

    render_summary() {
      python3 - <<'PY' "$template_path" "$session_file"
import json,os,sys

template_path = sys.argv[1]
session_path = sys.argv[2]

if not os.path.isfile(template_path):
  print(f"Template not found: {template_path}", file=sys.stderr)
  sys.exit(1)

with open(template_path, "r", encoding="utf-8") as f:
  template = f.read()

if not os.path.isfile(session_path):
  print("No active session. Run: dev.kit session start", file=sys.stderr)
  sys.exit(1)

with open(session_path, "r", encoding="utf-8") as f:
  session = json.load(f)

replacements = {
  "{{date}}": session.get("date", ""),
  "{{started_at}}": session.get("started_at", ""),
  "{{cwd}}": session.get("cwd", ""),
  "{{repo_root}}": session.get("repo_root", ""),
  "{{branch}}": session.get("branch", ""),
}

for key, value in replacements.items():
  template = template.replace(key, value or "")

print(template)
PY
    }

    case "$sub" in
      start)
        ensure_engine_dir
        if [ -f "$session_file" ]; then
          echo "Session already active: $session_file"
          exit 0
        fi
        date_ymd="$(date +%Y%m%d)"
        started_at="$(date -Iseconds)"
        cwd="$(pwd)"
        repo_root="$(get_repo_root)"
        branch="$(get_branch)"
        python3 - <<'PY' "$session_file" "$date_ymd" "$started_at" "$cwd" "$repo_root" "$branch"
import json,sys
path, date_ymd, started_at, cwd, repo_root, branch = sys.argv[1:]
data = {
  "id": f"session-{date_ymd}",
  "date": date_ymd,
  "started_at": started_at,
  "cwd": cwd,
  "repo_root": repo_root,
  "branch": branch
}
with open(path, "w", encoding="utf-8") as f:
  json.dump(data, f, indent=2)
print(f"Session started: {path}")
PY
        ;;
      status)
        if [ -f "$session_file" ]; then
          cat "$session_file"
        else
          echo "No active session. Run: dev.kit session start"
        fi
        ;;
      summary)
        render_summary
        ;;
      save)
        force="false"
        case "${3:-}" in
          --force) force="true" ;;
        esac
        preview_path="$DEV_KIT_HOME/session.preview.md"
        ensure_engine_dir
        render_summary > "$preview_path"
        echo "Preview:"
        cat "$preview_path"
        if [ -t 0 ] && [ "$force" != "true" ]; then
          printf "Save summary to docs/src/configs/experience/ ? [y/N] "
          read -r answer || true
          case "$answer" in
            y|Y|yes|YES) ;;
            *) echo "Aborted."; rm -f "$preview_path"; exit 1 ;;
          esac
        fi
        date_ymd="$(date +%Y%m%d)"
        if [ -f "$session_file" ]; then
          date_ymd="$(python3 - <<'PY' "$session_file"
import json,sys
with open(sys.argv[1], "r", encoding="utf-8") as f:
  print(json.load(f).get("date", ""))
PY
)"
        fi
        out_dir="$REPO_DIR/docs/src/configs/experience"
        mkdir -p "$out_dir"
        out_path="$out_dir/${date_ymd}_session.md"
        if [ -f "$out_path" ]; then
          i=1
          while [ -f "$out_dir/${date_ymd}_session_${i}.md" ]; do
            i=$((i+1))
          done
          out_path="$out_dir/${date_ymd}_session_${i}.md"
        fi
        mv "$preview_path" "$out_path"
        echo "Saved: $out_path"
        ;;
      -h|--help|"")
        cat <<'SESSION_USAGE'
Usage: dev.kit session <command>

Commands:
  start     Start a new work session
  status    Show current session data
  summary   Preview end-of-day summary
  save      Save summary to docs/src/configs/experience/
SESSION_USAGE
        ;;
      *)
        echo "Unknown session command: $sub" >&2
        exit 1
        ;;
    esac
    ;;
  capture)
    sub="${2:-}"
    capture_env="$DEV_KIT_HOME/capture.env"
    capture_state="$DEV_KIT_HOME/capture.state"
    capture_log="$DEV_KIT_HOME/capture.log"
    repo_root=""
    if command -v git >/dev/null 2>&1; then
      repo_root="$(git rev-parse --show-toplevel 2>/dev/null || true)"
    fi
    if [ -n "$repo_root" ]; then
      capture_env="$repo_root/.udx/dev.kit/capture/capture.env"
      capture_state="$repo_root/.udx/dev.kit/capture/capture.state"
      capture_log="$repo_root/.udx/dev.kit/capture/capture.log"
    fi
    capture_load_env() {
      if [ -f "$capture_env" ]; then
        # shellcheck disable=SC1090
        . "$capture_env"
      fi
    }
    shift 2 || true
    case "$sub" in
      start)
        mode="full"
        file=""
        auto_shell="true"
        default_full="$(config_bool capture.full true)"
        if [ "$default_full" = "false" ]; then
          mode="input"
        fi
        while [ $# -gt 0 ]; do
          case "$1" in
            --input) mode="input" ;;
            --no-shell) auto_shell="false" ;;
            *) file="$1" ;;
          esac
          shift
        done
        session_id="${DEV_KIT_CODEX_SESSION_ID:-${CODEX_SESSION_ID:-$(date +%Y%m%d%H%M%S)}}"
        session_ts="$(date -Iseconds)"
        if [ -z "$file" ]; then
          if [ -n "${DEV_KIT_CODEX_SESSION_ID:-${CODEX_SESSION_ID:-}}" ]; then
            file="${capture_log%.log}.${session_id}.log"
          else
            file="$capture_log"
          fi
        fi
        {
          echo "DEV_KIT_CAPTURE=1"
          echo "DEV_KIT_CAPTURE_MODE=$mode"
          echo "DEV_KIT_CAPTURE_SESSION=$session_id"
          echo "DEV_KIT_CAPTURE_STARTED_AT=$session_ts"
          if [ -n "$file" ]; then
            echo "DEV_KIT_CAPTURE_FILE=$file"
          fi
        } > "$capture_env"
        printf "cleaned=0\nheader_written=0\n" > "$capture_state"
        echo "capture: enabled ($mode)"
        echo "file: ${file:-<repo>/.udx/dev.kit/capture.log}"
        if [ "$mode" = "full" ]; then
          if [ "$auto_shell" = "true" ]; then
            echo "starting full capture shell..."
            "$REPO_DIR/bin/dev-kit" capture shell
            exit 0
          fi
          echo "note: full capture records stdout+stderr via:"
          echo "  dev.kit capture shell"
          echo "tip: use 'dev.kit capture start --input' for commands only"
        fi
        echo "reload: source \"$ENV_FILE\""
        ;;
      stop)
        echo "DEV_KIT_CAPTURE=0" > "$capture_env"
        echo "capture: disabled"
        echo "reload: source \"$ENV_FILE\""
        ;;
      status)
        enabled="$(config_bool capture.enabled false)"
        full="$(config_bool capture.full false)"
        auto_clean="$(config_bool capture.auto_clean false)"
        auto_clean_iteration="$(config_bool capture.auto_clean_iteration false)"
        ttl_global="$(config_value "$CONFIG_FILE" capture.ttl_days_global 3)"
        ttl_repo="$(config_value "$CONFIG_FILE" capture.ttl_days_repo 3)"
        file=""
        capture_load_env
        file="${DEV_KIT_CAPTURE_FILE:-}"
        echo "capture.enabled=$enabled"
        echo "capture.full=$full"
        echo "capture.auto_clean=$auto_clean"
        echo "capture.auto_clean_iteration=$auto_clean_iteration"
        echo "capture.ttl_days_global=$ttl_global"
        echo "capture.ttl_days_repo=$ttl_repo"
        if [ -n "$file" ]; then
          echo "capture.file=$file"
        fi
        if [ -f "$capture_env" ]; then
          echo ""
          echo "override:"
          cat "$capture_env"
        fi
        ;;
      show)
        capture_load_env
        log_file="${DEV_KIT_CAPTURE_FILE:-$capture_log}"
        if [ -f "$log_file" ]; then
          echo "file: $log_file"
          echo ""
          tail -n 50 "$log_file"
        else
          echo "No capture log found: $log_file"
        fi
        ;;
      shell)
        if ! command -v script >/dev/null 2>&1; then
          echo "Missing 'script' command. Install util-linux or use capture start."
          exit 1
        fi
        capture_load_env
        log_file="${DEV_KIT_CAPTURE_FILE:-$capture_log}"
        mkdir -p "$(dirname "$log_file")"
        if [ ! -f "$capture_env" ]; then
          session_id="$(date +%Y%m%d%H%M%S)"
          session_ts="$(date -Iseconds)"
          {
            echo "DEV_KIT_CAPTURE=1"
            echo "DEV_KIT_CAPTURE_MODE=full"
            echo "DEV_KIT_CAPTURE_SESSION=$session_id"
            echo "DEV_KIT_CAPTURE_STARTED_AT=$session_ts"
            echo "DEV_KIT_CAPTURE_FILE=$log_file"
          } > "$capture_env"
        fi
        printf "cleaned=0\nheader_written=0\n" > "$capture_state"
        echo "capture: full (stdout+stderr)"
        echo "file: $log_file"
        echo "exit: type 'exit' to stop"
        script -q -a "$log_file"
        ;;
      clear)
        force="false"
        case "${1:-}" in
          --force) force="true" ;;
        esac
        if [ -t 0 ]; then
          if [ "$force" != "true" ]; then
            printf "Clear capture log in current repo? [y/N] "
            read -r answer || true
            case "$answer" in
              y|Y|yes|YES) ;;
              *) echo "Aborted."; exit 1 ;;
            esac
          fi
        fi
        capture_load_env
        log_file="${DEV_KIT_CAPTURE_FILE:-$capture_log}"
        rm -f "$log_file"
        rm -f "$capture_state"
        echo "Cleared: $log_file"
        ;;
      auto-clean)
        case "${3:-}" in
          on) "$REPO_DIR/bin/dev-kit" config set capture.auto_clean true ;;
          off) "$REPO_DIR/bin/dev-kit" config set capture.auto_clean false ;;
          *) echo "Usage: dev.kit capture auto-clean <on|off>" ;;
        esac
        ;;
      -h|--help|"")
        cat <<'CAPTURE_USAGE'
Usage: dev.kit capture <command>

Commands:
  start [file]      Enable capture (default: full)
  start --input     Enable commands-only capture
  start --no-shell  Enable without starting full capture shell
  stop          Disable capture
  status        Show capture considering config
  show          Print capture log path and tail
  shell         Start a full capture shell (stdout+stderr)
  clear         Clear repo capture log (prompts)
  auto-clean    Toggle auto_clean on/off
CAPTURE_USAGE
        ;;
      *)
        echo "Unknown capture command: $sub" >&2
        exit 1
        ;;
    esac
    ;;
  config)
    ensure_dev_kit_home
    sub="${2:-}"
    ensure_global_config() {
      if [ ! -f "$CONFIG_FILE" ]; then
        if [ -f "$REPO_DIR/config/default.env" ]; then
          mkdir -p "$(dirname "$CONFIG_FILE")"
          cp "$REPO_DIR/config/default.env" "$CONFIG_FILE"
        fi
      fi
    }
    scope_path() {
      local scope="$1"
      local variant="$2"
      local base=""
      case "$scope" in
        global)
          base="$DEV_KIT_HOME"
          ;;
        repo)
          if command -v git >/dev/null 2>&1; then
            base="$(git rev-parse --show-toplevel 2>/dev/null)/.udx/dev.kit"
          fi
          ;;
        *)
          return 1
          ;;
      esac
      if [ -z "$base" ]; then
        return 1
      fi
      case "$variant" in
        show) echo "$base/config.env" ;;
        default) echo "$base/config.default.env" ;;
        min) echo "$base/config.min.env" ;;
        max) echo "$base/config.max.env" ;;
        custom) echo "$base/config.custom.env" ;;
        *) return 1 ;;
      esac
    }
    case "$sub" in
      global|repo)
        action="${3:---show}"
        case "$action" in
          --show|show) path="$(scope_path "$sub" show)" ;;
          --default|default) path="$(scope_path "$sub" default)" ;;
          --min|min) path="$(scope_path "$sub" min)" ;;
          --max|max) path="$(scope_path "$sub" max)" ;;
          --custom|custom) path="$(scope_path "$sub" custom)" ;;
          *)
            echo "Unknown config action: $action" >&2
            exit 1
            ;;
        esac
        if [ -z "${path:-}" ]; then
          echo "Config scope not available: $sub" >&2
          exit 1
        fi
        if [ "$sub" = "global" ]; then
          ensure_global_config
        fi
        if [ "$action" = "--custom" ] || [ "$action" = "custom" ]; then
          schema_artifact="$REPO_DIR/docs/artifacts/modules/config/local-schema.json"
          schema_source="$REPO_DIR/docs/src/configs/tooling/local/config-schema.json"
          schema_path="$schema_artifact"
          if [ ! -f "$schema_path" ]; then
            schema_path="$schema_source"
          fi
          if [ ! -f "$schema_path" ]; then
            echo "Config schema not found: $schema_artifact or $schema_source" >&2
            exit 1
          fi
          mkdir -p "$(dirname "$path")"
          python3 - "$schema_path" "$path" <<'PY'
import json
import os
import sys

schema_path, out_path = sys.argv[1], sys.argv[2]
with open(schema_path, "r", encoding="utf-8") as f:
    schema = json.load(f)

fields = schema.get("fields", [])
lines = []

def prompt(text):
    sys.stdout.write(text)
    sys.stdout.flush()
    return sys.stdin.readline().strip()

for field in fields:
    key = field.get("key")
    default = field.get("default", "")
    options = field.get("options") or []
    desc = field.get("description", "")
    if desc:
        sys.stdout.write(f"\n{desc}\n")
    if options:
        sys.stdout.write(f"options: {', '.join(options)}\n")
    value = prompt(f"{key} [{default}]: ")
    if not value:
        value = default
    lines.append(f"{key} = {value}\n")

with open(out_path, "w", encoding="utf-8") as f:
    f.writelines(lines)

print(f"Saved: {out_path}")
PY
          exit 0
        fi
        if [ -f "$path" ]; then
          cat "$path"
          exit 0
        fi
        if [ "$sub" = "repo" ]; then
          ensure_global_config
          if [ -f "$CONFIG_FILE" ]; then
            cat "$CONFIG_FILE"
            exit 0
          fi
        fi
        echo "Config file not found: $path" >&2
        exit 1
        ;;
      show|"")
        if [ -f "$CONFIG_FILE" ]; then
          cat "$CONFIG_FILE"
        else
          echo "No config found: $CONFIG_FILE"
        fi
        ;;
      reset)
        force="false"
        case "${3:-}" in
          --force) force="true" ;;
        esac
        if [ ! -f "$REPO_DIR/config/default.env" ]; then
          echo "Missing default config: $REPO_DIR/config/default.env"
          exit 1
        fi
        if [ -t 0 ] && [ "$force" != "true" ]; then
          printf "Reset config to defaults? [y/N] "
          read -r answer || true
          case "$answer" in
            y|Y|yes|YES) ;;
            *) echo "Aborted."; exit 1 ;;
          esac
        fi
        cp "$REPO_DIR/config/default.env" "$CONFIG_FILE"
        echo "Reset: $CONFIG_FILE"
        ;;
      set)
        key="${3:-}"
        value="${4:-}"
        if [ -z "$key" ] || [ -z "$value" ]; then
          echo "Usage: dev.kit config set <key> <value>"
          exit 1
        fi
        python3 - "$CONFIG_FILE" "$key" "$value" <<'PY'
import os,sys

path, key, value = sys.argv[1:]
lines = []
found = False

if os.path.exists(path):
    with open(path, "r", encoding="utf-8") as f:
        for line in f:
            if line.strip().startswith(f"{key}"):
                lines.append(f"{key} = {value}\n")
                found = True
            else:
                lines.append(line)
if not found:
    lines.append(f"{key} = {value}\n")

os.makedirs(os.path.dirname(path), exist_ok=True)
with open(path, "w", encoding="utf-8") as f:
    f.writelines(lines)
print(f"Set: {key} = {value}")
PY
        ;;
      -h|--help)
        cat <<'CONFIG_USAGE'
Usage: dev.kit config <command>

Commands:
  show           Print current config
  reset          Reset config to defaults (prompts)
  set            Set a config key/value
  global         Global config (use --show|--default|--min|--max|--custom)
  repo           Repo config (use --show|--default|--min|--max|--custom)
CONFIG_USAGE
        ;;
      *)
        echo "Unknown config command: $sub" >&2
        exit 1
        ;;
    esac
    ;;
  test)
    shift || true
    mock="true"
    module=""
    suite=""
    list="false"
    force="false"
    while [ $# -gt 0 ]; do
      case "$1" in
        -m|--mock)
          mock="true"
          ;;
        --run)
          mock="false"
          ;;
        --force)
          force="true"
          ;;
        --list)
          list="true"
          ;;
        --module=*)
          module="${1#--module=}"
          ;;
        --module)
          module="${2:-}"
          shift
          ;;
        --suite=*)
          suite="${1#--suite=}"
          ;;
        --suite)
          suite="${2:-}"
          shift
          ;;
        --all)
          module=""
          suite=""
          ;;
        -h|--help)
          cat <<'TEST_USAGE'
Usage: dev.kit test [<suite>] [--module <name>] [--suite <name>] [--mock|--run]

Options:
  --module <name>  Test a single module (default: all modules with schema.yml)
  --suite <name>   Run a named test suite from test/suites (default: all suites)
  --list           List available suites
  --force          Allow destructive suite steps (e.g., uninstall) against global dev.kit
  --mock, -m       Mock workflow commands (default)
  --run            Execute workflow commands when runnable
TEST_USAGE
          exit 0
          ;;
        *)
          if [[ "$1" != "-"* ]] && [ -z "$suite" ]; then
            suite="$1"
          else
            echo "Unknown option: $1" >&2
            exit 1
          fi
          ;;
      esac
      shift
    done

    python3 - "$REPO_DIR" "$module" "$suite" "$mock" "$list" "$force" <<'PY'
import json
import os
import subprocess
import sys

repo_dir = sys.argv[1]
module_filter = sys.argv[2].strip()
suite_filter = sys.argv[3].strip()
mock = sys.argv[4].lower() == "true"
list_only = sys.argv[5].lower() == "true"
force = sys.argv[6].lower() == "true"

modules_dir = os.path.join(repo_dir, "bin", "modules")
session_template = os.path.join(repo_dir, "src", "context", "20_config", "experience", "templates", "session-summary.md")
tests_root = os.path.join(repo_dir, "test")
suites_dir = os.path.join(tests_root, "suites")
output_dir = os.environ.get("DEV_KIT_TEST_OUTPUT_DIR", os.path.join(repo_dir, "tmp", "tests"))
log_file = os.environ.get("DEV_KIT_TEST_LOG_FILE", os.path.join(output_dir, "dev-kit-test.log"))
os.makedirs(output_dir, exist_ok=True)

def emit(message):
    print(message)
    with open(log_file, "a", encoding="utf-8") as handle:
        handle.write(message + "\n")

def resolve_vars(vars_map):
    resolved = {}
    for key, value in vars_map.items():
        if isinstance(value, str) and value.startswith("${") and value.endswith("}"):
            env_key = value[2:-1]
            resolved[key] = os.environ.get(env_key, "")
        else:
            resolved[key] = value
    return resolved

def expand_vars(text, vars_map):
    if not isinstance(text, str):
        return text
    out = text
    for key, value in vars_map.items():
        out = out.replace("${%s}" % key, str(value))
    return out

def has_uninstall(commands):
    for command in commands:
        if " uninstall" in command:
            return True
    return False

dev_kit_bin = os.environ.get("DEV_KIT_BIN", os.path.join(repo_dir, "bin", "dev-kit"))
shell_kind = os.environ.get("DEV_KIT_TEST_SHELL", "bash")
purge_flag = "--purge" if os.environ.get("DEV_KIT_TEST_PURGE", "false").lower() == "true" else ""

base_vars = {
    "DEV_KIT_BIN": dev_kit_bin,
    "SHELL_KIND": shell_kind,
    "PURGE_FLAG": purge_flag,
    "DEV_KIT_TEST_SHELL": shell_kind,
    "DEV_KIT_TEST_PURGE_FLAG": purge_flag,
}

if module_filter:
    modules = [module_filter]
else:
    modules = [
        name for name in os.listdir(modules_dir)
        if os.path.isfile(os.path.join(modules_dir, name, "schema.yml"))
    ]

exit_code = 0

run_modules = bool(module_filter) or not suite_filter
run_suites = bool(suite_filter) or not module_filter

if list_only:
    if not os.path.isdir(suites_dir):
        emit(f"[skip] suites dir missing: {suites_dir}")
        sys.exit(1)
    suite_files = [
        f for f in os.listdir(suites_dir)
        if f.endswith(".json")
    ]
    if not suite_files:
        emit("No suites found.")
        sys.exit(1)
    emit("Available suites:")
    for suite_file in sorted(suite_files):
        suite_path = os.path.join(suites_dir, suite_file)
        try:
            with open(suite_path, "r", encoding="utf-8") as f:
                suite = json.load(f)
            suite_id = suite.get("id", suite_file.replace(".json", ""))
            title = suite.get("title", "")
            label = f"{suite_id}"
            if title:
                label += f" - {title}"
            emit(f"  - {label}")
        except json.JSONDecodeError:
            emit(f"  - {suite_file.replace('.json', '')} (invalid JSON)")
    sys.exit(0)

if run_modules:
    if not modules:
        emit("No modules with schema.yml found.")
        exit_code = 1
    for name in sorted(modules):
        schema_path = os.path.join(modules_dir, name, "schema.yml")
        if not os.path.isfile(schema_path):
            emit(f"[skip] {name}: schema.yml not found")
            exit_code = 1
            continue

        with open(schema_path, "r", encoding="utf-8") as f:
            try:
                data = json.load(f)
            except json.JSONDecodeError as exc:
                emit(f"[error] {name}: schema.yml is not valid JSON/YAML ({exc})")
                exit_code = 1
                continue

        components = data.get("components", {})
        prompts = components.get("prompts", [])
        workflows = {wf.get("id"): wf for wf in components.get("workflows", [])}
        docs = components.get("docs", [])

        emit(f"== Module: {name} ==")
        emit(f"Docs: {len(docs)} | Workflows: {len(workflows)} | Prompts: {len(prompts)}")

        for prompt in prompts:
            prompt_text = prompt.get("text", "").strip()
            workflow_id = prompt.get("workflow_id") or prompt.get("command_id")
            if not workflow_id:
                emit(f"[error] prompt missing workflow_id: {prompt}")
                exit_code = 1
                continue
            workflow = workflows.get(workflow_id)
            if not workflow:
                emit(f"[error] workflow not found: {workflow_id}")
                exit_code = 1
                continue

            response = workflow.get("response", {})
            instructions = response.get("instructions", [])
            normalized = response.get("normalized", "").strip()
            if not instructions or not normalized:
                emit(f"[error] workflow response incomplete: {workflow_id}")
                exit_code = 1
                continue

            emit(f"- Prompt: {prompt_text or workflow_id}")
            emit(f"  Workflow: {workflow.get('title', workflow_id)}")
            emit(f"  Normalized: {normalized}")
            edge_cases = workflow.get("edge_cases", [])
            if edge_cases:
                emit("  Edge cases:")
                for item in edge_cases:
                    emit(f"    - {item}")
            emit("  Steps:")

            for step in workflow.get("steps", []):
                command = step.get("command")
                if not command:
                    continue
                runnable = step.get("runnable", True)
                interactive = step.get("interactive", False)
                protected = step.get("protected", False)
                preview_command = step.get("preview_command", "").strip()
                preview = step.get("preview", "").strip()
                command_l = command.lower()
                if "dev.kit session summary" in command or "dev.kit session save" in command:
                    if not os.path.isfile(session_template):
                        emit("[error] session summary template missing")
                        exit_code = 1
                if ("push" in command_l or "apply" in command_l) and not protected:
                    emit(f"[error] protected required for apply/push step: {command}")
                    exit_code = 1
                if protected and not preview_command and not preview:
                    emit(f"[error] protected step missing preview: {command}")
                    exit_code = 1
                if preview_command:
                    emit(f"    [preview] {preview_command}")
                elif preview:
                    emit(f"    [preview] {preview}")
                if mock or not runnable or interactive:
                    emit(f"    [mock] {command}")
                    continue
                emit(f"    [run] {command}")
                subprocess.run(command, shell=True, check=False)

        emit("")

if run_suites:
    if not os.path.isdir(suites_dir):
        emit(f"[skip] suites dir missing: {suites_dir}")
    else:
        suite_files = [
            f for f in os.listdir(suites_dir)
            if f.endswith(".json")
        ]
        if suite_filter:
            suite_files = [
                f for f in suite_files
                if f == f"{suite_filter}.json"
            ]
        for suite_file in sorted(suite_files):
            suite_path = os.path.join(suites_dir, suite_file)
            with open(suite_path, "r", encoding="utf-8") as f:
                try:
                    suite = json.load(f)
                except json.JSONDecodeError as exc:
                    emit(f"[error] suite {suite_file}: invalid JSON ({exc})")
                    exit_code = 1
                    continue

            suite_id = suite.get("id", suite_file)
            title = suite.get("title", suite_id)
            emit("")
            emit(f"== Suite: {suite_id} == {title}")

            vars_map = dict(base_vars)
            suite_vars = resolve_vars(suite.get("vars", {}))
            vars_map.update(suite_vars)

            expanded_commands = []
            for step in suite.get("steps", []):
                command = step.get("command")
                if not command:
                    continue
                expanded_commands.append(expand_vars(command, vars_map).strip())

            if not mock and not force and has_uninstall(expanded_commands):
                emit("[error] refusing to run suite with uninstall steps")
                emit("        rerun with --force to proceed")
                sys.exit(1)

            for step in suite.get("steps", []):
                command = step.get("command")
                if not command:
                    continue
                runnable = step.get("runnable", True)
                note = step.get("note", "")
                expanded = expand_vars(command, vars_map).strip()
                if note:
                    emit(f"    [note] {note}")
                if mock or not runnable:
                    emit(f"    [mock] {expanded}")
                    continue
                emit(f"    [run] {expanded}")
                subprocess.run(expanded, shell=True, check=False)

sys.exit(exit_code)
PY
    ;;
  doctor)
    if command -v ui_header >/dev/null 2>&1; then
      ui_header "dev.kit | doctor"
    else
      print_section "dev.kit Doctor"
    fi

    bin_dir="$HOME/.local/bin"
    target="$bin_dir/dev.kit"
    expected="$REPO_DIR/bin/dev-kit"

    in_path="no"
    case ":$PATH:" in
      *":$bin_dir:"*) in_path="yes" ;;
    esac
    if [ "$in_path" = "yes" ]; then
      print_check "PATH" "[ok]" "$bin_dir"
    else
      print_check "PATH" "[warn]" "missing $bin_dir"
    fi

    if command -v dev.kit >/dev/null 2>&1; then
      print_check "Binary" "[ok]" "$(command -v dev.kit)"
    else
      print_check "Binary" "[warn]" "dev.kit not found"
    fi

    if [ -L "$target" ]; then
      link_target="$(readlink "$target")"
      if [ "$link_target" = "$expected" ]; then
        print_check "Symlink" "[ok]" "$target -> $link_target"
      else
        print_check "Symlink" "[warn]" "$target -> $link_target"
      fi
    elif [ -e "$target" ]; then
      print_check "Symlink" "[warn]" "$target exists (not symlink)"
    else
      print_check "Symlink" "[warn]" "$target missing"
    fi

    if [ -d "$ENGINE_DIR" ]; then
      print_check "Engine dir" "[ok]" "$ENGINE_DIR"
    else
      print_check "Engine dir" "[warn]" "$ENGINE_DIR missing"
    fi

    if [ -f "$ENV_FILE" ]; then
      print_check "Env file" "[ok]" "$ENV_FILE"
    else
      print_check "Env file" "[warn]" "$ENV_FILE missing"
    fi

    if [ -f "$CONFIG_FILE" ]; then
      print_check "Config file" "[ok]" "$CONFIG_FILE"
    else
      print_check "Config file" "[warn]" "$CONFIG_FILE missing"
    fi

    rules_path="$HOME/.codex/rules/default.rules"
    if [ -f "$rules_path" ]; then
      print_check "Codex rules" "[ok]" "$rules_path"
    else
      print_check "Codex rules" "[warn]" "$rules_path missing"
    fi

    capture_enabled="$(config_bool capture.enabled false)"
    codex_suggest="$(config_bool codex_suggest false)"
    if [ "$codex_suggest" = "true" ] && [ "$capture_enabled" != "true" ]; then
      print_check "Capture" "[warn]" "disabled (consider: dev.kit capture start; auto-clean is configurable)"
    fi
    ;;
  clock)
    shift || true
    clock_cmd="${1:-start}"
    shift || true
    scope="dev.kit"
    root_dir=""
    global="false"

    while [ $# -gt 0 ]; do
      case "$1" in
        --scope=*)
          scope="${1#--scope=}"
          ;;
        --scope)
          scope="${2:-}"
          shift
          ;;
        --root=*)
          root_dir="${1#--root=}"
          ;;
        --root)
          root_dir="${2:-}"
          shift
          ;;
        --global)
          global="true"
          ;;
        -h|--help)
          cat <<'CLOCK_USAGE'
Usage: dev.kit clock <command> [--scope <name>] [--root <dir>] [--global]

Commands:
  start     Start or restart the wall-clock timer
  status    Show elapsed time
  reset     Clear the timer

Options:
  --scope <name>   Logical clock scope (default: dev.kit)
  --root <dir>     Override clock storage directory
  --global         Store under DEV_KIT_HOME instead of repo
CLOCK_USAGE
          exit 0
          ;;
        *)
          echo "Unknown clock option: ${1:-}" >&2
          exit 1
          ;;
      esac
      shift
    done

    if [ -n "$root_dir" ]; then
      clock_dir="$root_dir"
    elif [ "$global" = "true" ]; then
      clock_dir="$DEV_KIT_HOME/clock"
    else
      clock_dir="$REPO_DIR/.udx/dev.kit/clock"
    fi
    clock_file="$clock_dir/${scope}.env"

    case "$clock_cmd" in
      start|"")
        started_epoch="$(date +%s)"
        started_iso="$(date -Iseconds)"
        mkdir -p "$clock_dir"
        printf "started_epoch=%s\nstarted_iso=%s\n" "$started_epoch" "$started_iso" > "$clock_file"
        echo "clock.scope=$scope"
        echo "clock.started_at=$started_iso"
        echo "clock.file=$clock_file"
        ;;
      status)
        if [ ! -f "$clock_file" ]; then
          echo "clock: not started"
          exit 1
        fi
        # shellcheck disable=SC1090
        . "$clock_file"
        now_epoch="$(date +%s)"
        elapsed_sec=$((now_epoch - started_epoch))
        elapsed_min=$((elapsed_sec / 60))
        echo "clock.scope=$scope"
        echo "clock.started_at=$started_iso"
        echo "clock.elapsed_seconds=$elapsed_sec"
        echo "clock.elapsed_minutes=$elapsed_min"
        echo "clock.file=$clock_file"
        ;;
      reset|stop)
        rm -f "$clock_file"
        echo "clock: reset"
        ;;
      *)
        echo "Unknown clock command: ${clock_cmd:-}" >&2
        exit 1
        ;;
    esac
    ;;
  *)
    echo "Unknown command: $cmd" >&2
    usage
    exit 1
    ;;
esac
