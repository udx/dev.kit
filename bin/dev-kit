#!/bin/bash
set -euo pipefail

usage() {
  cat <<'USAGE'
Usage: dev.kit <command>

Commands:
USAGE
  local cmd
  while IFS= read -r cmd; do
    [ -n "$cmd" ] && printf "  %s\n" "$cmd"
  done < <(list_commands)
}

resolve_self() {
  local target="$0"
  if command -v realpath >/dev/null 2>&1; then
    realpath "$target"
    return
  fi
  if command -v readlink >/dev/null 2>&1; then
    while [ -L "$target" ]; do
      local link
      link="$(readlink "$target")"
      case "$link" in
        /*) target="$link" ;;
        *) target="$(cd "$(dirname "$target")" && cd "$(dirname "$link")" && pwd)/$(basename "$link")" ;;
      esac
    done
    local dir
    dir="$(cd "$(dirname "$target")" && pwd -P)"
    echo "$dir/$(basename "$target")"
    return
  fi
  echo "$target"
}

SCRIPT_PATH="$(resolve_self)"
REPO_DIR="$(cd "$(dirname "$SCRIPT_PATH")/.." && pwd)"

UI_LIB="$REPO_DIR/lib/ui.sh"
if [ -f "$UI_LIB" ]; then
  # shellcheck disable=SC1090
  . "$UI_LIB"
fi

print_section() {
  local title="$1"
  if command -v ui_section >/dev/null 2>&1; then
    ui_section "$title"
  else
    echo ""
    echo "== $title =="
  fi
}

print_check() {
  local label="$1"
  local status="$2"
  local detail="${3:-}"
  if command -v ui_ok >/dev/null 2>&1 && [ "$status" = "[ok]" ]; then
    ui_ok "$label" "$detail"
    return
  fi
  if command -v ui_warn >/dev/null 2>&1 && [ "$status" = "[warn]" ]; then
    ui_warn "$label" "$detail"
    return
  fi
  printf "%-20s %s" "$label" "$status"
  if [ -n "$detail" ]; then
    printf "  %s" "$detail"
  fi
  printf "\n"
}

ensure_dev_kit_home() {
  mkdir -p "$DEV_KIT_HOME"
  mkdir -p "$DEV_KIT_STATE"
  if [ ! -w "$DEV_KIT_STATE" ]; then
    echo "dev.kit: config path not writable: $DEV_KIT_STATE" >&2
    echo "dev.kit: fix permissions or choose a different DEV_KIT_STATE" >&2
    exit 1
  fi
  if [ ! -f "$CONFIG_FILE" ] && [ -f "$REPO_DIR/config/default.env" ]; then
    mkdir -p "$(dirname "$CONFIG_FILE")"
    cp "$REPO_DIR/config/default.env" "$CONFIG_FILE"
  fi
}

config_value() {
  local file="$1"
  local key="$2"
  local default="${3:-}"
  local val=""
  if [ -f "$file" ]; then
    val="$(awk -F= -v k="$key" '
      $1 ~ "^[[:space:]]*"k"[[:space:]]*$" {
        sub(/^[[:space:]]*/,"",$2);
        sub(/[[:space:]]*$/,"",$2);
        print $2;
        exit
      }
    ' "$file")"
  fi
  if [ -n "$val" ]; then
    echo "$val"
  else
    echo "$default"
  fi
}

get_repo_root() {
  if command -v git >/dev/null 2>&1; then
    git rev-parse --show-toplevel 2>/dev/null || true
  fi
}

local_config_path() {
  local root
  root="$(get_repo_root)"
  if [ -n "$root" ]; then
    echo "$root/.udx/dev.kit/config.env"
  fi
}

config_value_scoped() {
  local key="$1"
  local default="${2:-}"
  local local_path=""
  local val=""

  local_path="$(local_config_path || true)"
  if [ -n "$local_path" ] && [ -f "$local_path" ]; then
    val="$(config_value "$local_path" "$key" "")"
  fi
  if [ -n "$val" ]; then
    echo "$val"
    return
  fi
  config_value "$CONFIG_FILE" "$key" "$default"
}

capture_mode() {
  local mode=""
  mode="$(config_value_scoped capture.mode "")"
  if [ -n "$mode" ]; then
    echo "$mode"
    return
  fi
  local enabled=""
  enabled="$(config_value_scoped capture.enabled "true")"
  if [ "$enabled" = "true" ]; then
    echo "global"
  else
    echo "off"
  fi
}

capture_repo_id() {
  local root=""
  root="$(get_repo_root || true)"
  if [ -z "$root" ]; then
    root="$PWD"
  fi
  if command -v shasum >/dev/null 2>&1; then
    printf "%s" "$root" | shasum -a 256 | awk '{print $1}'
  else
    printf "%s" "$root" | cksum | awk '{print $1}'
  fi
}

capture_dir() {
  local mode base repo_id
  mode="$(capture_mode)"
  case "$mode" in
    off) return 1 ;;
    repo)
      base="$(get_repo_root || true)"
      if [ -z "$base" ]; then
        base="$PWD"
      fi
      echo "$base/.udx/dev.kit/capture"
      ;;
    global|*)
      base="$(config_value_scoped capture.dir "")"
      if [ -z "$base" ]; then
        base="$DEV_KIT_STATE/capture"
      elif [[ "$base" == "~/"* ]]; then
        base="$HOME/${base:2}"
      elif [[ "$base" != /* ]]; then
        base="$DEV_KIT_STATE/$base"
      fi
      repo_id="$(capture_repo_id)"
      echo "$base/$repo_id"
      ;;
  esac
}

capture_enabled() {
  local mode=""
  mode="$(capture_mode)"
  [ "$mode" != "off" ]
}

context_enabled() {
  local enabled=""
  enabled="$(config_value_scoped context.enabled "true")"
  [ "$enabled" = "true" ]
}

context_dir() {
  if ! context_enabled; then
    return 1
  fi
  local base repo_id
  base="$(config_value_scoped context.dir "")"
  if [ -z "$base" ]; then
    base="$DEV_KIT_STATE/codex/context"
  elif [[ "$base" == "~/"* ]]; then
    base="$HOME/${base:2}"
  elif [[ "$base" != /* ]]; then
    base="$DEV_KIT_STATE/$base"
  fi
  repo_id="$(capture_repo_id)"
  echo "$base/$repo_id"
}

context_file() {
  local dir=""
  dir="$(context_dir)" || return 1
  echo "$dir/context.md"
}

context_max_bytes() {
  config_value_scoped context.max_bytes "12000"
}

context_compact_file() {
  local path="$1"
  local max_bytes=""
  max_bytes="$(context_max_bytes)"
  if [ -z "$max_bytes" ] || [ ! -f "$path" ]; then
    return 0
  fi
  local size=""
  size="$(wc -c < "$path" | tr -d ' ')"
  if [ -z "$size" ] || [ "$size" -le "$max_bytes" ]; then
    return 0
  fi
  local tmp="${path}.tmp.$$"
  if tail -c "$max_bytes" "$path" > "$tmp"; then
    mv "$tmp" "$path"
  else
    rm -f "$tmp"
  fi
}

capture_prepare() {
  local dir input_path output_path
  dir="$(capture_dir)" || return 1
  input_path="$dir/last-input.log"
  output_path="$dir/last-output.log"
  mkdir -p "$dir"
  : > "$input_path"
  : > "$output_path"
  printf "%s | %s | %s\n" "$(date -Iseconds)" "$PWD" "$1" >> "$input_path"
  printf "%s\n" "$output_path"
}

DEV_KIT_OWNER="${DEV_KIT_OWNER:-udx}"
DEV_KIT_REPO="${DEV_KIT_REPO:-dev.kit}"
DEV_KIT_HOME="${DEV_KIT_HOME:-$HOME/.${DEV_KIT_OWNER}/${DEV_KIT_REPO}}"

bootstrap_state_path() {
  local path=""
  if [ -f "$DEV_KIT_HOME/config.env" ]; then
    path="$(awk -F= '
      $1 ~ "^[[:space:]]*state_path[[:space:]]*$" {
        gsub(/[[:space:]]/,"",$2);
        print $2;
        exit
      }
    ' "$DEV_KIT_HOME/config.env")"
  fi
  printf "%s" "$path"
}

bootstrap_expand_path() {
  local val="$1"
  if [[ "$val" == "~/"* ]]; then
    echo "$HOME/${val:2}"
    return
  fi
  if [[ "$val" == /* ]]; then
    echo "$val"
    return
  fi
  if [ -n "$val" ]; then
    echo "$DEV_KIT_HOME/$val"
    return
  fi
  echo ""
}

BOOTSTRAP_STATE_PATH="$(bootstrap_expand_path "$(bootstrap_state_path)")"
DEV_KIT_STATE="${DEV_KIT_STATE:-${BOOTSTRAP_STATE_PATH:-$DEV_KIT_HOME/state}}"
DEV_KIT_SOURCE="${DEV_KIT_SOURCE:-$DEV_KIT_HOME/source}"
if [ ! -d "$DEV_KIT_SOURCE" ]; then
  DEV_KIT_SOURCE="$DEV_KIT_HOME"
fi
if [ ! -d "$DEV_KIT_STATE" ]; then
  DEV_KIT_STATE="$DEV_KIT_HOME"
fi
CONFIG_FILE="${DEV_KIT_CONFIG:-$DEV_KIT_STATE/config.env}"
if [ ! -f "$CONFIG_FILE" ] && [ -f "$DEV_KIT_HOME/config.env" ]; then
  CONFIG_FILE="$DEV_KIT_HOME/config.env"
fi

expand_path() {
  local val="$1"
  if [[ "$val" == "~/"* ]]; then
    echo "$HOME/${val:2}"
    return
  fi
  if [[ "$val" == /* ]]; then
    echo "$val"
    return
  fi
  echo "$REPO_DIR/$val"
}

list_commands() {
  local file=""
  for file in "$REPO_DIR"/lib/commands/*.sh; do
    [ -e "$file" ] || continue
    basename "${file%.sh}"
  done | LC_ALL=C sort
}

for cmd_file in "$REPO_DIR"/lib/commands/*.sh; do
  [ -e "$cmd_file" ] || continue
  # shellcheck disable=SC1090
  . "$cmd_file"
done

orig_args=("$@")
cmd="${1:-help}"
case "$cmd" in
  help|-h|--help)
    usage
    exit 0
    ;;
esac

fn="dev_kit_cmd_${cmd//-/_}"
if ! command -v "$fn" >/dev/null 2>&1; then
  echo "Unknown command: $cmd" >&2
  echo ""
  usage
  exit 1
fi

ensure_dev_kit_home
if [ "$cmd" = "capture" ]; then
  "$fn" "$@"
  exit $?
fi
if capture_enabled; then
  full_cmd="dev.kit ${orig_args[*]}"
  output_path="$(capture_prepare "$full_cmd")"
  "$fn" "$@" 2>&1 | tee "$output_path"
  exit $?
fi

"$fn" "$@"
