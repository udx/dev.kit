{
  "title": "CDE definition",
  "summary": "Context Driven Engineering (CDE) is a repository standard that keeps artifacts consistent across human, programmatic, and AI contexts. This document defines CDE for dev.kit.",
  "_order": [
    "transformation",
    "purpose",
    "standardsStack",
    "developmentContextLayers",
    "vocabulary",
    "repositoryStructure",
    "artifactsAndBuild",
    "validationTests",
    "designPrinciple",
    "extensions"
  ],
  "transformation": {
    "_heading": "Transformation",
    "items": [
      "Prompt: see `Prompt(CDE schema builder)` in this file.",
      "Destination: `public/schema/index.json`."
    ]
  },
  "purpose": {
    "_heading": "Purpose",
    "items": [
      "Define the CDE standard for dev.kit.",
      "Provide a shared vocabulary and model across human, programmatic, and AI contexts.",
      "Keep CDE principles stable even as modules evolve."
    ]
  },
  "standardsStack": {
    "_heading": "Standards stack",
    "items": [
      {
        "text": "**Software source standard (build)**",
        "items": [
          "Defines how source artifacts are discovered, built, tested, scanned, signed, and packaged."
        ]
      },
      {
        "text": "**12-factor GitHub repo standard (deployment)**",
        "items": [
          "Defines how repositories behave as deployable units via conventions, declarative configuration, and environment separation."
        ]
      },
      {
        "text": "**Context Driven Engineering (active context layer)**",
        "items": [
          "Defines how execution context influences behavior across all layers. This layer is always active and never bypassed."
        ]
      }
    ]
  },
  "developmentContextLayers": {
    "_heading": "Development context layers",
    "_order": [
      "humanBuild",
      "programmaticDeploy",
      "aiContext"
    ],
    "humanBuild": {
      "_heading": "human/build",
      "summary": "Human-initiated, interactive build execution.",
      "items": [
        {
          "id": "custom",
          "description": "Parameterized, operator-defined execution path."
        },
        {
          "id": "real-time",
          "description": "Observable execution with live feedback and step visibility."
        },
        {
          "id": "multi-step",
          "description": "Guided execution flow with state, checkpoints, and progressive disclosure."
        }
      ]
    },
    "programmaticDeploy": {
      "_heading": "programmatic/deploy",
      "summary": "Machine-initiated, deterministic deployment execution.",
      "items": [
        {
          "id": "inputs",
          "description": "Explicit input contract (flags, payloads, schema-validated parameters)."
        },
        {
          "id": "default",
          "description": "Opinionated execution using standard inputs and conventions."
        },
        {
          "id": "single/scroll",
          "description": "Single, linear execution record optimized for inspection and automation."
        }
      ]
    },
    "aiContext": {
      "_heading": "ai/context",
      "summary": "Context-aware, adaptive execution and orchestration.",
      "items": [
        {
          "id": "interpret",
          "description": "Derives intent from partial, ambiguous, or conversational input."
        },
        {
          "id": "compose",
          "description": "Assembles workflows dynamically from standards and active context."
        },
        {
          "id": "mediate",
          "description": "Bridges human intent and programmatic execution safely and predictably."
        },
        {
          "id": "optimize",
          "description": "Adjusts steps, ordering, or defaults based on historical and situational context."
        }
      ]
    }
  },
  "vocabulary": {
    "_heading": "Vocabulary",
    "summary": "Vocabulary is layer-agnostic and maps consistently across experiences.",
    "_order": [
      "coreTerms",
      "experience",
      "aiEssentialsAndHumanAnalogy"
    ],
    "coreTerms": {
      "_heading": "Core terms",
      "items": [
        {
          "id": "context-layer",
          "description": "A directory that contains an `index.md`. Only such directories participate in CDE context resolution."
        },
        {
          "id": "context-asset",
          "description": "A markdown document located within a context layer (typically `index.md` or any document under that layer's `context/` subtree)."
        },
        {
          "id": "context-schema",
          "description": "A JSON configuration that defines machine-validated structure for a context layer (e.g., `index.json`, `schema.json`, or an embedded JSON schema block)."
        }
      ]
    },
    "experience": {
      "_heading": "Experience",
      "items": [
        {
          "id": "interactive",
          "description": "Human-friendly guided or conversational flow (CLI wizard, UI, AI-guided)."
        },
        {
          "id": "programmatic",
          "description": "Machine-friendly, explicit and deterministic (CLI flags, API payloads, CI pipelines)."
        },
        {
          "id": "integrated",
          "description": "Declarative, configuration-driven (config files, repo manifests, policy definitions)."
        }
      ]
    },
    "aiEssentialsAndHumanAnalogy": {
      "_heading": "AI essentials and human analogy",
      "_order": [
        "aiEssentials",
        "humanCapabilityBuild",
        "programmaticCapabilityDeploy"
      ],
      "aiEssentials": [
        {
          "aiEssential": "**interpret**",
          "humanAnalogyWhatItLooksLike": "Clarify intent, restate requirements, ask the right steps",
          "typicalOutputArtifact": "Intent summary"
        },
        {
          "aiEssential": "**compose**",
          "humanAnalogyWhatItLooksLike": "Draft a runbook, choose an approach, sequence steps",
          "typicalOutputArtifact": "Plan / workflow spec"
        },
        {
          "aiEssential": "**mediate**",
          "humanAnalogyWhatItLooksLike": "Gatekeeping, approvals, policy checks, safety reviews",
          "typicalOutputArtifact": "Decision record"
        },
        {
          "aiEssential": "**optimize**",
          "humanAnalogyWhatItLooksLike": "Refactor, simplify, reuse patterns, avoid repetition",
          "typicalOutputArtifact": "Improved plan / defaults"
        }
      ],
      "humanCapabilityBuild": [
        {
          "humanCapabilityBuild": "**custom**",
          "aiAnalogWhatAiDoes": "Parameter selection and constraint satisfaction",
          "typicalOutputArtifact": "Parameter set"
        },
        {
          "humanCapabilityBuild": "**real-time**",
          "aiAnalogWhatAiDoes": "Live summarization + anomaly surfacing",
          "typicalOutputArtifact": "Status narrative"
        },
        {
          "humanCapabilityBuild": "**multi-step**",
          "aiAnalogWhatAiDoes": "Stateful orchestration + checkpointing",
          "typicalOutputArtifact": "Step trace"
        }
      ],
      "programmaticCapabilityDeploy": [
        {
          "programmaticCapabilityDeploy": "**inputs**",
          "aiAnalogWhatAiDoes": "Schema-driven extraction/validation",
          "typicalOutputArtifact": "Validated payload"
        },
        {
          "programmaticCapabilityDeploy": "**default**",
          "aiAnalogWhatAiDoes": "Default selection using context + policy",
          "typicalOutputArtifact": "Resolved configuration"
        },
        {
          "programmaticCapabilityDeploy": "**single/scroll**",
          "aiAnalogWhatAiDoes": "Post-run synthesis into one consumable trace",
          "typicalOutputArtifact": "Run report"
        }
      ]
    }
  },
  "repositoryStructure": {
    "_heading": "Repository structure",
    "items": [
      "`src/` Source manifests for humans, programs, and AI, including the CDE definition.",
      "`src/context/` Layered context and build rules; see `src/context/index.md` for the dispatcher model.",
      "`public/` Built artifacts intended to be copied or consumed directly.",
      "`public/schema/` JSON artifacts derived from Markdown sources."
    ]
  },
  "artifactsAndBuild": {
    "_heading": "Artifacts and build",
    "items": [
      "Sources live under `src/` and `src/context/`.",
      "Outputs live under `public/`.",
      "Build steps must document inputs, outputs, and any client-specific overlays."
    ]
  },
  "validationTests": {
    "_heading": "Validation & tests",
    "items": [
      "Human readability is the primary goal.",
      "Machine parsing should be simple, deterministic, and tolerant of minor variations.",
      "AI context depends on prompt generation and may vary across clients."
    ]
  },
  "designPrinciple": {
    "_heading": "Design principle",
    "summary": "The same action must be expressible as:",
    "items": [
      "a conversation (AI),",
      "a guided flow (human),",
      "a contract (programmatic),"
    ],
    "notes": [
      "without changing its meaning.",
      "AI does not introduce a new execution model; it acts as a context compiler that selects the appropriate layer and experience."
    ]
  },
  "extensions": {
    "notes": [
      {
        "_heading": "Prompt(CDE schema builder)",
        "value": "You are a deterministic converter that transforms a single CDE Markdown document into a single JSON artifact.\n\nTenet: the Markdown is the configuration and source of truth. This prompt is only the script. Do not embed or assume any CDE-specific content beyond the generic conversion rules below.\n\nOutput requirements\n- Output JSON only. No markdown fences, no commentary.\n- Deterministic: same input -> same JSON output.\n- Do not invent content. If something is absent in Markdown, omit it in JSON (unless required by the schema you infer from the Markdown itself).\n- Preserve literals exactly (code blocks, inline code, tokens like $vars). Never execute or expand variables.\n- Prefer stable identifiers and round-trip safety.\n\nParsing and normalization rules\n\n1) Document framing\n- H1 becomes: title\n- The first paragraph after H1 (if any) becomes: summary\n\n2) Headings -> structure\n- H2 headings create top-level JSON sections.\n- H3+ headings create nested objects inside their nearest parent section.\n- Heading keys must be normalized to lowerCamelCase.\n- Preserve original heading text in an optional field: _heading (string) when useful for round-trip fidelity.\n\n3) Lists\n- Numbered lists become arrays preserving order.\n- Bullet lists become arrays.\n- Definition-style bullets are detected and normalized:\n  - Pattern A: \"**term**: description\" -> object { id, description }\n  - Pattern B: \"term: description\" (when term is short and description is longer) -> object { id, description }\n- Normalize ids:\n  - If the id contains \"/\" keep it as-is.\n  - Otherwise lower-case; convert spaces to \"-\" (kebab-case); strip surrounding punctuation.\n\n4) Tables\n- Markdown tables become arrays of row objects.\n- Header cells become object keys (normalized to lowerCamelCase).\n- Keep dashes and placeholders as literal strings (do not coerce to null).\n\n5) Code blocks and literals\n- Any fenced code block becomes an object:\n  { \"type\": \"code\", \"lang\": \"<lang or empty>\", \"value\": \"<exact contents>\" }\n- Attach code objects to the closest relevant section based on proximity:\n  - If inside a heading section, store under that section.\n  - If unclear, store in a top-level array: literals[].\n\n6) Inline code\n- Preserve inline code verbatim in the surrounding string content.\n- Do not interpret inline code as structure unless it matches a definition/list rule.\n\n7) Round-trip fidelity\n- Preserve order where meaningful:\n  - For each object created from headings, optionally include _order: [<child keys in appearance order>].\n  - For arrays derived from lists, preserve list order.\n- If you encounter content that does not fit any rule, store it under:\n  extensions: { notes: [ ... ] }\n  Do not drop information.\n\n8) Root metadata\n- If the Markdown provides explicit spec/version metadata, include it.\n- If not provided, omit spec/version fields (do not guess).\n\n9) Final output\n- Emit one JSON object as the sole output.\n- Ensure the JSON is valid, UTF-8, and uses consistent key naming (lowerCamelCase for keys; ids as described above)."
      }
    ]
  }
}
