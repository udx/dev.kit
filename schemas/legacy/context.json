{
  "title": "CDE context system",
  "summary": "The CDE context system is the handler and dispatcher for structured context in dev.kit. It uses integrated metadata, supports unlimited nested levels, and treats CDE-compliant context documents as configuration sources for different output types.",
  "_order": [
    "transformation",
    "contextDispatcher",
    "developmentContextLayers",
    "dynamicSchema",
    "mergeOrder",
    "dynamicVariables",
    "naming",
    "dynamicStructure",
    "navigation",
    "artifacts",
    "validationTests",
    "contextLayers",
    "standardsStack",
    "vocabulary",
    "keyDesignPrinciple",
    "extensions"
  ],
  "transformation": {
    "_heading": "Transformation",
    "items": [
      "Prompt: see `Prompt(Context schema builder)` in this file.",
      "Destination: `src/schema/context.json`."
    ]
  },
  "contextDispatcher": {
    "_heading": "Context dispatcher",
    "items": [
      "`src/context` is the context handler and dispatcher for dev.kit.",
      "Context documents are configuration inputs for different output types.",
      "Context layers can be nested without a depth limit.",
      "Integrated metadata is required to support deterministic parsing and merging."
    ]
  },
  "developmentContextLayers": {
    "_heading": "Development context layers",
    "items": [
      "Software-specific standard (build).",
      "12-factor GitHub repo standard (deployment).",
      "Context Driven Engineering standard (active context layer)."
    ]
  },
  "dynamicSchema": {
    "_heading": "Dynamic schema",
    "items": [
      "`index.md` defines global config schema rules (applies to all nested levels).",
      "Child `index.md` extends parent rules; overrides are allowed only if parent explicitly permits."
    ]
  },
  "mergeOrder": {
    "_heading": "Merge order",
    "items": [
      "Parent rules apply first, then child rules.",
      "If overrides are permitted, child values replace parent values for the same key.",
      "If overrides are not permitted, child can only add new keys."
    ]
  },
  "dynamicVariables": {
    "_heading": "Dynamic variables",
    "items": [
      "`$child` resolves to all child dirs in the current directory. Alias for `$child.dirs`.",
      "`$child.files` resolves to all child files in the current directory.",
      "`$child[context]` resolves to all child files in `context/`. If absent or empty, returns `[]`.",
      "Non-wrapped variables are executable.",
      "Non-executable text: wrap in code fences to keep literal."
    ]
  },
  "naming": {
    "_heading": "Naming",
    "items": [
      "Use lowercase kebab-case for directory and file names.",
      "Use `index.md` as the entry point for each directory."
    ]
  },
  "dynamicStructure": {
    "_heading": "Dynamic structure",
    "items": [
      "`src/`: CDE definition and global standards for dev.kit.",
      "`src/context/`: context dispatcher and layered context documents.",
      "`artifacts/`: build and execution outputs."
    ]
  },
  "navigation": {
    "_heading": "Navigation",
    "items": [
      "Each directory should contain an `index.md` that documents its direct children.",
      "If missing, default behavior applies but may be inaccurate due to metadata absence.",
      "Do not list deep files here; rely on child indexes for discovery."
    ]
  },
  "artifacts": {
    "_heading": "Artifacts",
    "items": [
      "Artifacts are derived with `dev.kit build [--context=configs/modules/ai/codex]` by related context definition.",
      "Artifacts can be markdown, json, yml, or other module-specific formats."
    ]
  },
  "validationTests": {
    "_heading": "Validation & Tests",
    "items": [
      "Keep docs human-readable first.",
      "Machine parsing should be simple, deterministic, and tolerate minor variations.",
      "AI context depends on prompt generation and may vary across clients.",
      "Explicit sections/headings are optional but recommended when they improve clarity."
    ]
  },
  "contextLayers": {
    "_heading": "Context layers",
    "_order": [
      "humanBuild",
      "programmaticDeploy",
      "aiContext"
    ],
    "humanBuild": {
      "_heading": "human/build",
      "summary": "Human-initiated, interactive build execution.",
      "items": [
        {
          "id": "custom",
          "description": "Parameterized, operator-defined execution path."
        },
        {
          "id": "real-time",
          "description": "Observable execution with live feedback and step visibility."
        },
        {
          "id": "multi-step",
          "description": "Guided execution flow with state, checkpoints, and progressive disclosure (wizard-style, context-aware)."
        }
      ]
    },
    "programmaticDeploy": {
      "_heading": "programmatic/deploy",
      "summary": "Machine-initiated, deterministic deployment execution.",
      "items": [
        {
          "id": "inputs",
          "description": "Explicit input contract (flags, payloads, schema-validated parameters)."
        },
        {
          "id": "default",
          "description": "Opinionated execution using standard inputs and conventions."
        },
        {
          "id": "single/scroll",
          "description": "Single, linear execution record optimized for inspection and automation."
        }
      ]
    },
    "aiContext": {
      "_heading": "ai/context",
      "summary": "Context-aware, adaptive execution and orchestration.",
      "items": [
        {
          "id": "interpret",
          "description": "Derives intent from partial, ambiguous, or conversational input."
        },
        {
          "id": "compose",
          "description": "Assembles workflows dynamically from standards and active context."
        },
        {
          "id": "mediate",
          "description": "Bridges human intent and programmatic execution safely and predictably."
        },
        {
          "id": "optimize",
          "description": "Adjusts steps, ordering, or defaults based on historical and situational context."
        }
      ]
    }
  },
  "standardsStack": {
    "_heading": "Standards stack",
    "items": [
      {
        "text": "Software Source Standard (Build)",
        "items": [
          "Defines how source artifacts are discovered, built, tested, and packaged.",
          "Language and runtime conventions.",
          "Build steps and artifacts.",
          "Test and scan expectations."
        ]
      },
      {
        "text": "12-Factor GitHub Repo Standard (Deployment)",
        "items": [
          "Defines how repositories behave as deployable units.",
          "Declarative configuration.",
          "Environment separation.",
          "Immutable artifacts.",
          "Explicit backing services."
        ]
      },
      {
        "text": "Context Driven Engineering Standard (Active Context Layer)",
        "items": [
          "Defines how context influences execution across all layers.",
          "Who is acting (human, system, AI).",
          "Why the action is occurring (intent).",
          "Where it runs (environment, trust boundary).",
          "What constraints apply (policy, security, compliance).",
          "What is already known (history, state, artifacts).",
          "This layer is always active and never bypassed."
        ]
      }
    ]
  },
  "vocabulary": {
    "_heading": "Vocabulary",
    "summary": "Vocabulary is layer-agnostic and maps consistently across experiences.",
    "_order": [
      "experience",
      "vocabularyLayerMappingConceptual"
    ],
    "experience": {
      "_heading": "Experience",
      "items": [
        {
          "id": "interactive",
          "description": "Human-friendly, conversational or wizard-based flow (CLI step-by-step, UI, AI-guided)."
        },
        {
          "id": "programmatic",
          "description": "Machine-friendly, explicit and deterministic (CLI flags, API payloads, CI pipelines)."
        },
        {
          "id": "integrated",
          "description": "Declarative, configuration-driven (config files, repo manifests, policy definitions)."
        }
      ]
    },
    "vocabularyLayerMappingConceptual": {
      "_heading": "Vocabulary - Layer Mapping (Conceptual)",
      "items": [
        {
          "vocabulary": "interactive",
          "humanBuild": "Wizard, live logs",
          "programmaticDeploy": "-",
          "aiContext": "Conversational intent"
        },
        {
          "vocabulary": "programmatic",
          "humanBuild": "Optional overrides",
          "programmaticDeploy": "Primary interface",
          "aiContext": "Execution target"
        },
        {
          "vocabulary": "integrated",
          "humanBuild": "Presets, profiles",
          "programmaticDeploy": "Defaults, contracts",
          "aiContext": "Context memory"
        }
      ]
    }
  },
  "keyDesignPrinciple": {
    "_heading": "Key design principle",
    "summary": "The same action must be expressible as:",
    "items": [
      "a conversation (AI),",
      "a guided flow (human),",
      "or a contract (programmatic),",
      "without changing its meaning."
    ],
    "notes": [
      "AI does not introduce a new execution model.",
      "It operates as a context compiler that selects the appropriate layer and experience."
    ]
  },
  "extensions": {
    "notes": [
      {
        "_heading": "Prompt(Context schema builder)",
        "value": "You are a deterministic converter that transforms a single CDE context Markdown document into a single JSON artifact.\n\nTenet: the Markdown is the configuration and source of truth. This prompt is only the script. Do not embed or assume any CDE-specific content beyond the generic conversion rules below.\n\nOutput requirements\n- Output JSON only. No markdown fences, no commentary.\n- Deterministic: same input -> same JSON output.\n- Do not invent content. If something is absent in Markdown, omit it in JSON (unless required by the schema you infer from the Markdown itself).\n- Preserve literals exactly (code blocks, inline code, tokens like $vars). Never execute or expand variables.\n- Prefer stable identifiers and round-trip safety.\n\nParsing and normalization rules\n\n1) Document framing\n- H1 becomes: title\n- The first paragraph after H1 (if any) becomes: summary\n\n2) Headings -> structure\n- H2 headings create top-level JSON sections.\n- H3+ headings create nested objects inside their nearest parent section.\n- Heading keys must be normalized to lowerCamelCase.\n- Preserve original heading text in an optional field: _heading (string) when useful for round-trip fidelity.\n\n3) Lists\n- Numbered lists become arrays preserving order.\n- Bullet lists become arrays.\n- Definition-style bullets are detected and normalized:\n  - Pattern A: \"**term**: description\" -> object { id, description }\n  - Pattern B: \"term: description\" (when term is short and description is longer) -> object { id, description }\n- Normalize ids:\n  - If the id contains \"/\" keep it as-is.\n  - Otherwise lower-case; convert spaces to \"-\" (kebab-case); strip surrounding punctuation.\n\n4) Tables\n- Markdown tables become arrays of row objects.\n- Header cells become object keys (normalized to lowerCamelCase).\n- Keep dashes and placeholders as literal strings (do not coerce to null).\n\n5) Code blocks and literals\n- Any fenced code block becomes an object:\n  { \"type\": \"code\", \"lang\": \"<lang or empty>\", \"value\": \"<exact contents>\" }\n- Attach code objects to the closest relevant section based on proximity:\n  - If inside a heading section, store under that section.\n  - If unclear, store in a top-level array: literals[].\n\n6) Inline code\n- Preserve inline code verbatim in the surrounding string content.\n- Do not interpret inline code as structure unless it matches a definition/list rule.\n\n7) Round-trip fidelity\n- Preserve order where meaningful:\n  - For each object created from headings, optionally include _order: [<child keys in appearance order>].\n  - For arrays derived from lists, preserve list order.\n- If you encounter content that does not fit any rule, store it under:\n  extensions: { notes: [ ... ] }\n  Do not drop information.\n\n8) Root metadata\n- If the Markdown provides explicit spec/version metadata, include it.\n- If not provided, omit spec/version fields (do not guess).\n\n9) Final output\n- Emit one JSON object as the sole output.\n- Ensure the JSON is valid, UTF-8, and uses consistent key naming (lowerCamelCase for keys; ids as described above)."
      }
    ]
  }
}
